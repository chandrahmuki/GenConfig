"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const coc_nvim_1 = require("coc.nvim");
const which_1 = tslib_1.__importDefault(require("which"));
function configDir(...names) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const home = require('os').homedir();
        const dir = path_1.default.join(home, '.config', 'coc', 'sh', ...names);
        return new Promise((resolve) => {
            fs_1.default.mkdirSync(dir, { recursive: true });
            resolve(dir);
        });
    });
}
exports.configDir = configDir;
function pkgBin(name) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let bin = path_1.default.join(yield configDir('tools'), 'node_modules', '.bin', name);
        try {
            bin = fs_1.default.realpathSync(bin);
        }
        catch (e) { }
        return bin;
    });
}
exports.pkgBin = pkgBin;
function pkgBinExists(name) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const bin = yield pkgBin(name);
        return new Promise(resolve => fs_1.default.open(bin, 'r', (err, _) => resolve(err === null)));
    });
}
exports.pkgBinExists = pkgBinExists;
function pkgInstall(name, force = false) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!force && (yield pkgBinExists(name))) {
            return;
        }
        return yarnRun(`add ${name}`);
    });
}
exports.pkgInstall = pkgInstall;
function pkgUpgrade(name) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return yarnRun(`upgrade ${name}`);
    });
}
exports.pkgUpgrade = pkgUpgrade;
function yarnRun(args) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const toolsPath = yield configDir('tools');
        const cmd = `cd ${toolsPath}; npm ${args}`;
        const res = yield coc_nvim_1.workspace.runTerminalCommand(cmd);
        return res.success;
    });
}
function commandExists(command) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise(resolve => which_1.default(command, (err, _) => resolve(err == null)));
    });
}
exports.commandExists = commandExists;
//# sourceMappingURL=utils.js.map